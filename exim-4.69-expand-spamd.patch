diff --git a/src/spam.c b/src/spam.c
index bf2470c..aab96c6 100644
--- a/src/spam.c
+++ b/src/spam.c
@@ -1,4 +1,4 @@
-/* $Cambridge: exim/exim-src/src/spam.c,v 1.14 2007/05/14 18:56:25 magnus Exp $ */
+/* $Cambridge: exim/exim-src/src/spam.c,v 1.16 2008/01/28 13:14:48 tom Exp $ */
 
 /*************************************************
 *     Exim - an Internet mail transport agent    *
@@ -46,6 +46,7 @@ int spam(uschar **listptr) {
   struct timeval select_tv;         /* and applied by PH */
   fd_set select_fd;
 #endif
+  uschar *spamd_address_work;
 
   /* stop compiler warning */
   result = 0;
@@ -89,14 +90,26 @@ int spam(uschar **listptr) {
   };
 
   start = time(NULL);
+
+  if (*spamd_address == '$') {
+    spamd_address_work = expand_string(spamd_address);
+    if (spamd_address_work == NULL) {
+      log_write(0, LOG_MAIN|LOG_PANIC,
+        "spamassassin acl condition: spamd_address starts with $, but expansion failed: %s", expand_string_message);
+      return DEFER;
+    }
+  }
+  else
+    spamd_address_work = spamd_address;
+
   /* socket does not start with '/' -> network socket */
-  if (*spamd_address != '/') {
+  if (*spamd_address_work != '/') {
     time_t now = time(NULL);
     int num_servers = 0;
     int current_server = 0;
     int start_server = 0;
     uschar *address = NULL;
-    uschar *spamd_address_list_ptr = spamd_address;
+    uschar *spamd_address_list_ptr = spamd_address_work;
     uschar address_buffer[256];
     spamd_address_container * spamd_address_vector[32];
 
@@ -184,12 +197,12 @@ int spam(uschar **listptr) {
     }
 
     server.sun_family = AF_UNIX;
-    Ustrcpy(server.sun_path, spamd_address);
+    Ustrcpy(server.sun_path, spamd_address_work);
 
     if (connect(spamd_sock, (struct sockaddr *) &server, sizeof(struct sockaddr_un)) < 0) {
       log_write(0, LOG_MAIN|LOG_PANIC,
                 "malware acl condition: spamd: unable to connect to UNIX socket %s (%s)",
-                spamd_address, strerror(errno) );
+                spamd_address_work, strerror(errno) );
       (void)fclose(mbox_file);
       (void)close(spamd_sock);
       return DEFER;
@@ -395,9 +408,11 @@ again:
     spam_rc = FAIL;
   };
 
-  /* remember user name and "been here" for it */
-  Ustrcpy(prev_user_name, user_name);
-  spam_ok = 1;
+  /* remember user name and "been here" for it unless spamd_socket was expanded */
+  if (spamd_address_work == spamd_address) {
+    Ustrcpy(prev_user_name, user_name);
+    spam_ok = 1;
+  }
 
   if (override) {
     /* always return OK, no matter what the score */
